package poly.collection

import poly.algebra.hkt._
import poly.collection.mut._
import scala.language.implicitConversions

/**
 * `Iterable[T]` is the basic trait for all collections that exposes an iterator.
 * `Iterable`s differ from `Traversable`s in that the iteration process can be controlled:
 * It can be paused or resumed by the user.
 *
 * This trait is created to replace the `Iterable` Java interface or the `Iterable` Scala
 * trait in Poly-collection.
 *
 * @author Tongfei Chen (ctongfei@gmail.com).
 */
trait Iterable[+T] extends Traversable[T] { self =>

  import Iterable._

  /** Returns a new iterator that can be used to iterate through this collection. */
  def newIterator: Iterator[T]


  //region HELPER FUNCTIONS

  def foreach[V](f: T => V) = newIterator.foreach(f)

  override def map[U](f: T => U) = ofIterator(self.newIterator.map(f))

  def flatMap[U](f: T => Iterable[U]) = ofIterator(self.newIterator.flatMap(x => f(x).newIterator))

  def cartesianProduct[U](that: Iterable[U]): Iterable[(T, U)] = self.flatMap(t => that.map(u => (t, u)))

  override def filter(f: T => Boolean) = ofIterator(self.newIterator.filter(f))

  override def filterNot(f: T => Boolean) = ofIterator(self.newIterator.filterNot(f))

  def concat[U >: T](that: Iterable[U]): Iterable[U] = ofIterator(self.newIterator concat that.newIterator)

  override def prepend[U >: T](u: U): Iterable[U] = ofIterator(self.newIterator prepend u)

  override def append[U >: T](u: U): Iterable[U] = ofIterator(self.newIterator append u)

  override def tail: Iterable[T] = ofIterator(self.newIterator.tail)

  override def take(n: Int): Iterable[T] = ofIterator(self.newIterator.take(n))

  override def skip(n: Int): Iterable[T] = ofIterator(self.newIterator.drop(n))

  override def slice(i: Int, j: Int): Iterable[T] = ofIterator(self.newIterator.slice(i, j))

  def distinct: Iterable[T] = ???

  def zip[U](that: Iterable[U]): Iterable[(T, U)] = ofIterator(self.newIterator zip that.newIterator)

  def zip3[U, V](us: Iterable[U], vs: Iterable[V]): Iterable[(T, U, V)] = ofIterator {
    new Iterator[(T, U, V)] {
      val ti = self.newIterator
      val ui = us.newIterator
      val vi = vs.newIterator
      def advance(): Boolean = ti.advance() && ui.advance() && vi.advance()
      def current: (T, U, V) = (ti.current, ui.current, vi.current)
    }
  }

  def interleave[U >: T](that: Iterable[U]): Iterable[U] =
    Iterable.ofIterator(self.newIterator interleave that.newIterator)

  def sliding(windowSize: Int, step: Int = 1) = ofIterator(self.newIterator.sliding(windowSize, step))

  //endregion


  //region symbolic aliases
  override def +:[U >: T](u: U): Iterable[U] = prepend(u)
  override def :+[U >: T](u: U): Iterable[U] = append(u)
  def ++[U >: T](that: Iterable[U]) = this concat that
  def Ã—[U](that: Iterable[U]) = this cartesianProduct that
  override def |>[U](f: T => U) = this map f
  def |>>[U](f: T => Iterable[U]) = this flatMap f
  //endregion
}

object Iterable {

  object empty extends Iterable[Nothing] {
    def newIterator: Iterator[Nothing] = Iterator.empty
  }

  /** Creates an iterable collection based on an existing iterator. The iterator is a call-by-name argument. */
  def ofIterator[T](e: => Iterator[T]): Iterable[T] = new AbstractIterable[T] {
    def newIterator = e // call-by-name parameter!
  }

  /**
   * Constructs an infinite collection that is generated by repeatedly applying a given function to
   * a start value. $LAZY
   * @param s Start value
   * @param next Function
   * @return An infinite sequence
   */
  def iterate[T](s: T)(next: T => T) = ofIterator(Iterator.iterate(s)(next))

  /** Returns the natural monad on Iterables. */
  implicit object Monad extends Monad[Iterable] {
    def flatMap[X, Y](mx: Iterable[X])(f: (X) => Iterable[Y]): Iterable[Y] = mx.flatMap(f)
    def id[X](u: X): Iterable[X] = ListSeq(u)
  }

  implicit def optionAsIterable[T](o: Option[T]): Iterable[T] = new AbstractIterable[T] {
    def newIterator = o match {
      case Some(x) => Iterator.single(x)
      case None => Iterator.empty
    }
  }
}

abstract class AbstractIterable[+T] extends AbstractTraversable[T] with Iterable[T]
